// Generated by CoffeeScript 1.8.0
(function() {
  var Server, debug, fs, net, readline, stream;

  net = require('net');

  fs = require('fs');

  debug = (require('debug'))('fq:Server');

  readline = require('readline');

  stream = require('stream');

  Server = (function() {
    var generateFileName, getCurrentFilePath, getOffset, getSockPath, newFile, onCloseHandler, openFile, pickupLastFile, setCurrentFile, setCurrentFileCount, setOffset, startServer, validateParam;

    function Server(config) {
      this._file = null;
      this._filename = null;
      this._messagesInFile = 0;
      this._fileSize = 0;
      this._rl = null;
      this.path = validateParam('path', config);
      this.name = validateParam('name', config);
      this.maxMessagesPerFile = parseInt(config.maxMessagesPerFile || 1000);
      this.maxFileSize = parseInt(config.maxFileSize || 1024 * 100);
      startServer(this);
      pickupLastFile(this);
      onCloseHandler(this);
    }

    onCloseHandler = function(self) {
      return process.on('SIGINT', function() {
        setCurrentFileCount(self);
        return process.exit();
      });
    };

    getSockPath = function(self) {
      return '/tmp/' + self.name + '.sock';
    };

    startServer = function(self) {
      if (fs.existsSync(getSockPath(self))) {
        fs.unlinkSync(getSockPath(self));
      }
      this._server = net.createServer((function(_this) {
        return function(sock) {
          var streamPass;
          streamPass = new stream.PassThrough();
          self._rl = readline.createInterface({
            input: streamPass,
            output: new stream
          });
          self._rl.on('line', function(line) {
            return self.push(line.toString());
          });
          sock.on('data', function(data) {
            return streamPass.write(data);
          });
          sock.on('end', function() {
            return debug('Client disconnected');
          });
          return sock.on('connection', function() {
            return debug('Client connected');
          });
        };
      })(this));
      return this._server.listen(getSockPath(self), function() {
        return debug('Server listening');
      });
    };

    validateParam = function(param, config) {
      if (!config[param]) {
        throw Error("Provide " + param + " in config object");
      } else {
        return config[param];
      }
    };

    pickupLastFile = function(self) {
      var fileMessagesCount, lastFile;
      lastFile = self.path + '/.' + self.name + '_current_file';
      fileMessagesCount = self.path + '/.' + self.name + '_current_file_count';
      if (fs.existsSync(lastFile)) {
        lastFile = fs.readFileSync(lastFile, {
          encoding: 'utf8'
        });
        fileMessagesCount = fs.readFileSync(fileMessagesCount, {
          encoding: 'utf8'
        });
        self._fileSize = fs.statSync(self.path + '/' + lastFile)['size'];
        self._messagesInFile = fileMessagesCount;
        self._filename = lastFile;
        debug('Picking last file: %s, message count: %s, size: %s', lastFile, fileMessagesCount, self._fileSize);
        openFile(self);
        return setCurrentFile(self);
      }
    };

    Server.prototype.push = function(msg, cb) {
      if (!this._file || this._messagesInFile >= this.maxMessagesPerFile || this._fileSize >= this.maxFileSize) {
        newFile(this);
      }
      msg += "\n";
      this._messagesInFile++;
      this._fileSize += Buffer.byteLength(msg, 'utf8');
      return this._file.write(msg, (function(_this) {
        return function(err) {
          if (err) {
            debug(err);
          }
          return cb && cb();
        };
      })(this));
    };

    Server.prototype.getMessagesCount = function() {
      return this._messagesInFile;
    };

    Server.prototype.getFileSize = function() {
      return this._fileSize;
    };

    Server.prototype.getFilePath = function() {
      return this._filepath;
    };

    generateFileName = function(self) {
      return self.name + '_' + new Date().getTime();
    };

    getCurrentFilePath = function(self) {
      return self.path + '/' + self._filename;
    };

    Server.prototype.closeFile = function(cb) {
      var cp, offset;
      if (!this._file) {
        return;
      }
      this._file.end();
      debug('Closing file %s, current message count: %s, size: %s', this._filename, this._messagesInFile, this._fileSize);
      if (this._messagesInFile === 0) {
        debug('File is empty, deleting file %s', this.path);
        fs.unlinkSync(this.path);
        return;
      }
      cp = getCurrentFilePath(this);
      offset = getOffset(this) + this._messagesInFile;
      setOffset(this, offset);
      return fs.renameSync(cp, cp + '_' + this._messagesInFile);
    };

    getOffset = function(self) {
      var offset, offsetFile;
      offsetFile = self.path + '/.' + self.name + '_offset';
      if (fs.existsSync(offsetFile)) {
        offset = parseInt(fs.readFileSync(offsetFile, {
          encoding: 'utf8'
        })) || 0;
        return offset;
      } else {
        return 0;
      }
    };

    setOffset = function(self, offset) {
      return fs.writeFileSync(self.path + '/.' + self.name + '_offset', offset);
    };

    setCurrentFileCount = function(self) {
      return fs.writeFileSync(self.path + '/.' + self.name + '_current_file_count', self._messagesInFile);
    };

    setCurrentFile = function(self) {
      return fs.writeFileSync(self.path + '/.' + self.name + '_current_file', self._filename);
    };

    openFile = function(self) {
      var fp;
      fp = getCurrentFilePath(self);
      return self._file = fs.createWriteStream(fp, {
        flags: 'a'
      });
    };

    newFile = function(self) {
      self.closeFile();
      self._messagesInFile = 0;
      self._fileSize = 0;
      self._filename = generateFileName(self);
      openFile(self);
      setCurrentFile(self);
      return debug('New file', self._filename);
    };

    return Server;

  })();

  module.exports = Server;

}).call(this);
